[BOJ 1152번] 단어의 개수
===============
### 1) 접근
처음에는 공백 개수를 세려고 했는데, 문자열 앞뒤에도 공백이 있을 수 있다는 걸 깨닫고 예외 처리가 너무 지저분해서 걍 단어를 직접 잘라 저장하는 방식으로 짰다.

### 2) 풀이(C++11)
```c++
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

int main(void){
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int cnt = 0;
    string s;
    getline(cin, s, '\n');

    istringstream inp_string(s);
    string string_buffer;

    while(getline(inp_string, string_buffer, ' ')) { if(string_buffer != "") ++cnt; }
    cout << cnt;

    return 0;
}
```

### 3) 피드백
내가 푼 방식은 쉽게 쉽게 짜는 방식일지 모르나 불필요하게 시간, 공간을 잡아먹는 면이 크다. string_buffer 같은 변수를 쓴다든지, getline 같은 함수까지 쓴다든지… 좀 더 나은 해법을 찾아봤다.

- 앞에 공백, 뒤에 문자가 오는 횟수를 count

아래는 상당히 체계적으로 짰다고 생각하는 코드다. 이건 비단 이 문제상황 뿐만 아니라 공백의 연속이 존재할 때 등 보다 일반적인 상황에서도 깔끔하게 적용된다는 점에서 상당히 맘에 든다.(C++11)
```c++
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int is_alpha(char c) {
    if( ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'))
        return 1;
    else
        return 0;
}


char *strip_space(char *str) {
    while(*str == ' ') str++;

    if(*str == 0 )
        return str;
    
    char *end = str + strlen(str) - 1;
    while( (end > str) && ((*end == 0x20) || (*end == 0xa)) ) {
        end--;
    }

    end[1] = 0;
    return str;
}


int main() {
    char buf[1000001] = { 0, };
    char *ptr;
    int cnt = 0;

    read(0, buf, 1000000);

    ptr = strip_space(buf);
    if(is_alpha(ptr[0])) cnt=1;

    for(int i = 0; i < strlen(ptr); i++) {
        if(ptr[i] == ' ') {
            cnt++;
        }
    }
    
    printf("%d\n", cnt);
    return 0;
}
```
